{"ast":null,"code":"var _jsxFileName = \"/Users/berkgaffaroglu/Documents/MemoryChallange/memorychallange/src/components/FetchRandomWords.js\";\nimport React, { Component } from 'react';\nimport Game from './Game';\nexport class FetchRandomWords extends Component {\n  constructor(props) {\n    super(props); // initializing the variables that I am going to use later.\n\n    this.state = {\n      level: 1,\n      score: 0,\n      speed: 1,\n      wordList: [],\n      correctWordList: [],\n      wrongWordList: [],\n      gameStarted: false,\n      memorizingEnded: false,\n      errors: false\n    };\n    this.fetchRandomWords = this.fetchRandomWords.bind(this);\n    this.gameLogic = this.gameLogic.bind(this);\n    this.handleNextLevel = this.handleNextLevel.bind(this);\n  }\n\n  gameLogic() {\n    var correctWordList = this.state.correctWordList;\n    var wrongWordList = this.state.wrongWordList;\n    this.setState({\n      wordList: correctWordList\n    }); // For each level there will be more words to memorize so we have to multiply by level to wait and the more we increase\n    // the speed seconds to wait will be lesser\n\n    var waitSeconds = this.state.level * 1000 * 3 / this.state.speed; // in miliseconds\n    // replacing the wordList with shuffled list which contains both correct and wrong words.\n\n    var wordList = correctWordList.concat(wrongWordList);\n    wordList = wordList.sort(() => Math.random() - 0.5);\n    console.log(waitSeconds / 1000);\n    setTimeout(() => {\n      this.setState({\n        wordList: wordList,\n        memorizingEnded: true\n      });\n    }, waitSeconds);\n  } // Helper function to divide the list by correct ones and wrong ones.\n\n\n  handleStringManipulation(lst) {\n    var correctWordList = [];\n    var wrongWordList = [];\n    lst.map(function (word) {\n      // The words that ends with :C are the correct ones.\n      if (word.slice(-2) == ':C') {\n        let wordToPush = word.slice(0, word.length - 2);\n        correctWordList.push(wordToPush);\n      } else {\n        wrongWordList.push(word);\n      }\n    });\n    this.setState({\n      correctWordList: correctWordList,\n      wrongWordList: wrongWordList\n    }); // Calling the next function\n\n    this.gameLogic();\n  }\n\n  async fetchRandomWords(level) {\n    try {\n      // Fetching 3 words for each level\n      var totalWords = level * 3; // 1 out of 3 word will be wrong which will be shown of the end of memorization\n\n      var wrongWords = totalWords / 3;\n      let response = await fetch(this.props.websiteUrl + `api/get-random-words/total=${totalWords}/wrong=${wrongWords}`);\n      let data = await response.json(); // We are seperating the words by their last 2 character which is \":C\"\n\n      this.handleStringManipulation(data); // If there is any error handle it by changing the state errors:true.\n    } catch (err) {\n      this.setState({\n        errors: true\n      });\n    }\n  }\n\n  handleNextLevel() {\n    this.setState(state => ({\n      level: state.level + 1,\n      gameStarted: true\n    }));\n    this.fetchRandomWords(this.state.level);\n  }\n\n  render() {\n    // destructing this.state to have cleaner code.\n    const {\n      errors,\n      wordList,\n      level,\n      score\n    } = this.state; // If level is 0 display start button else display next level button\n\n    if (this.state.gameStarted == false) {\n      if (level == 1) {\n        var buttonElement = /*#__PURE__*/React.createElement(\"button\", {\n          onClick: () => this.handleNextLevel(),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 100,\n            columnNumber: 38\n          }\n        }, \"Start\");\n      } else {\n        var buttonElement = /*#__PURE__*/React.createElement(\"button\", {\n          onClick: () => this.handleNextLevel(),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 102,\n            columnNumber: 41\n          }\n        }, \"Next level\");\n      }\n    } // If the game is started don't display the next level button\n    else {\n        var buttonElement = /*#__PURE__*/React.createElement(React.Fragment, null);\n        var endQuestions = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h1\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 111,\n            columnNumber: 21\n          }\n        }, \"What word didn't shown?\"), this.state.wordList.map(function (word, index) {\n          return /*#__PURE__*/React.createElement(\"a\", {\n            key: index,\n            href: \"#\",\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 114,\n              columnNumber: 29\n            }\n          }, word);\n        }));\n      }\n\n    if (!errors) {\n      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h1\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 125,\n          columnNumber: 21\n        }\n      }, level - 1 != 0 ? /*#__PURE__*/React.createElement(React.Fragment, null, \" Level: \", level - 1, \" \") : /*#__PURE__*/React.createElement(React.Fragment, null)), /*#__PURE__*/React.createElement(\"h1\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 21\n        }\n      }, level - 1 != 0 ? /*#__PURE__*/React.createElement(React.Fragment, null, \" Score: \", score, \" \") : /*#__PURE__*/React.createElement(React.Fragment, null)), this.state.memorizingEnded ? endQuestions : wordList, /*#__PURE__*/React.createElement(\"br\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 128,\n          columnNumber: 21\n        }\n      }), buttonElement);\n    } // Error handling\n    else if (errors) {\n        return /*#__PURE__*/React.createElement(React.Fragment, null, \"Something is wrong. Please try again.\");\n      }\n  }\n\n}\nexport default FetchRandomWords;","map":{"version":3,"sources":["/Users/berkgaffaroglu/Documents/MemoryChallange/memorychallange/src/components/FetchRandomWords.js"],"names":["React","Component","Game","FetchRandomWords","constructor","props","state","level","score","speed","wordList","correctWordList","wrongWordList","gameStarted","memorizingEnded","errors","fetchRandomWords","bind","gameLogic","handleNextLevel","setState","waitSeconds","concat","sort","Math","random","console","log","setTimeout","handleStringManipulation","lst","map","word","slice","wordToPush","length","push","totalWords","wrongWords","response","fetch","websiteUrl","data","json","err","render","buttonElement","endQuestions","index"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport Game from './Game'\nexport class FetchRandomWords extends Component {\n    constructor(props) {\n        super(props)\n        // initializing the variables that I am going to use later.\n        this.state = {\n            level: 1,\n            score: 0,\n            speed: 1,\n            wordList: [],\n            correctWordList: [],\n            wrongWordList: [],\n            gameStarted: false,\n            memorizingEnded: false,\n            errors: false,\n\n        }\n        this.fetchRandomWords = this.fetchRandomWords.bind(this)\n        this.gameLogic = this.gameLogic.bind(this)\n        this.handleNextLevel = this.handleNextLevel.bind(this)\n    }\n\n\n    gameLogic() {\n        var correctWordList = this.state.correctWordList\n        var wrongWordList = this.state.wrongWordList\n        this.setState({\n            wordList: correctWordList\n        })\n        // For each level there will be more words to memorize so we have to multiply by level to wait and the more we increase\n        // the speed seconds to wait will be lesser\n        var waitSeconds = this.state.level * 1000 * 3 / this.state.speed // in miliseconds\n        // replacing the wordList with shuffled list which contains both correct and wrong words.\n        var wordList = correctWordList.concat(wrongWordList)\n        wordList = wordList.sort(() => Math.random() - 0.5);\n        console.log(waitSeconds / 1000)\n        setTimeout(() => {\n            this.setState({\n                wordList: wordList,\n                memorizingEnded: true\n            })\n        }, waitSeconds);\n    }\n\n\n    // Helper function to divide the list by correct ones and wrong ones.\n    handleStringManipulation(lst) {\n        var correctWordList = []\n        var wrongWordList = []\n        lst.map(function (word) {\n            // The words that ends with :C are the correct ones.\n            if (word.slice(-2) == ':C') {\n                let wordToPush = word.slice(0, word.length - 2)\n                correctWordList.push(wordToPush)\n            } else { wrongWordList.push(word) }\n        })\n        this.setState({\n            correctWordList: correctWordList,\n            wrongWordList: wrongWordList\n        })\n        // Calling the next function\n        this.gameLogic()\n    }\n\n\n    async fetchRandomWords(level) {\n        try {\n            // Fetching 3 words for each level\n            var totalWords = level * 3\n            // 1 out of 3 word will be wrong which will be shown of the end of memorization\n            var wrongWords = totalWords / 3\n            \n            let response = await (fetch(this.props.websiteUrl + `api/get-random-words/total=${totalWords}/wrong=${wrongWords}`));\n            let data = await response.json();\n\n            // We are seperating the words by their last 2 character which is \":C\"\n            this.handleStringManipulation(data)\n\n            // If there is any error handle it by changing the state errors:true.\n        } catch (err) {\n            this.setState({ errors: true, })\n        }\n\n    }\n\n\n    handleNextLevel() {\n        this.setState((state) => ({ level: state.level + 1, gameStarted: true }));\n        this.fetchRandomWords(this.state.level)\n    }\n\n\n    render() {\n        // destructing this.state to have cleaner code.\n        const { errors, wordList, level, score } = this.state\n        // If level is 0 display start button else display next level button\n        if (this.state.gameStarted == false) {\n            if (level == 1) {\n                var buttonElement = (<button onClick={() => this.handleNextLevel()}>Start</button>)\n            }\n            else { var buttonElement = (<button onClick={() => this.handleNextLevel()}>Next level</button>) }\n        }\n\n        // If the game is started don't display the next level button\n        else {\n            var buttonElement = (<></>)\n\n            var endQuestions = (\n                <>\n                    <h1>What word didn't shown?</h1>\n                    {this.state.wordList.map(function (word, index) {\n                        return (\n                            <a key={index} href=\"#\">{word}</a>\n                        )\n                    })}\n                </>\n            )\n\n        }\n\n        if (!errors) {\n            return (\n                <>\n                    <h1>{level - 1 != 0 ? <> Level: {level - 1} </> : <></>}</h1>\n                    <h1>{level - 1 != 0 ? <> Score: {score} </> : <></>}</h1>\n                    {this.state.memorizingEnded ? endQuestions : wordList}\n                    <br />\n                    {buttonElement}\n                </>\n            )\n        }\n\n        // Error handling\n        else if (errors) {\n            return (<>Something is wrong. Please try again.</>)\n        }\n    }\n}\n\nexport default FetchRandomWords\n"]},"metadata":{},"sourceType":"module"}